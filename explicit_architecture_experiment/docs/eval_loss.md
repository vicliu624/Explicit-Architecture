# 🧩 指标设计说明

# 以语言模型预测损失（`eval_loss`）表征模块耦合复杂度

## 一、研究背景与目标

在显性架构实验中，我们希望量化模块间依赖对开发者和系统复杂性的影响。传统静态指标（如 `import_coupling`、`call_coupling`）可以衡量模块间直接依赖数量，但无法反映**模块内函数实现与外部上下文的隐性复杂关系**。

因此，本实验引入**语言模型预测损失（`eval_loss`）**作为补充指标：

* 通过微调预训练语言模型，让模型根据模块上下文（导入语句、函数调用等）预测函数体。
* 预测难度越高，说明上下文依赖复杂、模块耦合强，函数实现越依赖外部模块。
* 损失 `eval_loss` 作为量化模块耦合复杂度的代理指标。

---

## 二、理论假设（Assumptions）

采用语言模型预测损失作为耦合复杂度指标的理论假设如下：

| 假设编号   | 内容                                | 对应概念    |
| ------ | --------------------------------- | ------- |
| **L1** | 模块函数体的可预测性受模块上下文信息量影响。            | 上下文复杂性  |
| **L2** | 上下文依赖越多（导入模块越多、调用越频繁），函数体的预测难度越高。 | 模块耦合度   |
| **L3** | 语言模型的交叉熵损失（`eval_loss`）可以量化预测难度。  | 耦合复杂度代理 |

换言之：

> “如果一个模块的函数体在给定上下文下难以预测，则说明它与其他模块高度耦合；反之，易预测意味着模块解耦良好。”

---

## 三、指标定义（Metrics Definition）

### 1. Eval Loss (`eval_loss`)

定义：给定模块上下文（导入语句、调用关系等） $X$ 和函数体目标 $Y$，语言模型在因果语言建模下的平均交叉熵损失：

$$
\text{eval\_loss}(m) = - \frac{1}{|Y|} \sum_{t=1}^{|Y|} \log P_\theta(y_t \mid y_{<t}, X)
$$
其中：

* (m) 为模块
* (Y = {y_1, ..., y_{|Y|}}) 为模块函数体的 token 序列
* (X) 为模块上下文，包括 `import` 和 `call` 信息
* (P_\theta) 为微调后的语言模型预测概率

解释：

* 高 `eval_loss` → 模块上下文复杂、依赖多、函数体难以预测 → 耦合复杂度高
* 低 `eval_loss` → 模块上下文简单、依赖少、函数体容易预测 → 耦合复杂度低

---

## 四、指标合理性与适用性

| 维度        | 说明                                                        |
| --------- | --------------------------------------------------------- |
| **理论合理性** | 模块间耦合增加了实现复杂性和函数体不可预测性，损失值可作为代理指标。                        |
| **计算可行性** | 可通过标准 Transformer 语言模型微调实现，支持大规模代码库。                      |
| **可解释性**  | 损失值高低直接对应“函数实现在给定上下文下的难易程度”。                              |
| **统计稳定性** | 在大样本训练下，损失分布稳定，可与 `import_coupling`、`call_coupling` 结合分析。 |
| **局限性**   | 不是传统意义的耦合度度量；损失受模型容量、训练策略和数据规模影响，需要与静态指标联合解释。             |

---

## 五、指标与静态耦合指标的关系

语言模型预测损失与静态耦合指标的关系如下：

| 静态指标              | 作用      | 对应 eval_loss                     |
| ----------------- | ------- | -------------------------------- |
| `import_coupling` | 静态依赖数量  | 导入越多，模型上下文越长，预测函数体难度上升 → loss 增加 |
| `call_coupling`   | 动态调用复杂度 | 调用越多，函数逻辑与其他模块关联越紧密 → loss 增加    |
| `coupling_score`  | 综合耦合    | loss 在统计层面体现综合依赖强度               |

> 换句话说，`eval_loss` 可以视作**模块耦合复杂度的动态/隐性补充指标**，与静态指标互为验证。

---

## 六、实验解释示例

假设对两类架构微调语言模型得到的结果如下：

| 架构类型         | eval_loss |
| ------------ | --------- |
| non_explicit | 3.45      |
| explicit     | 2.10      |

结论：

* 显性架构模块函数体预测更容易 → 模块耦合更低
* 非显性架构预测困难 → 模块耦合复杂 → 高耦合度验证了静态指标趋势

---

## 七、总结

> 语言模型预测损失 `eval_loss` 是一种**动态耦合复杂度代理指标**。
> 它通过测量函数体在给定模块上下文下的可预测性，间接反映模块间的依赖强度。
> 虽然受模型容量和训练策略影响，但在统计层面上，它稳定、可复现、可归一化，**非常适合用于机器学习实验中的架构比较分析**。